% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/json_schema.R
\name{json_schema}
\alias{json_schema}
\title{Create a schema for a JSON document or collection}
\usage{
json_schema(x)
}
\arguments{
\item{x}{a json string or a tbl_json object}
}
\value{
a character string JSON document that represents the schema of
        the collection
}
\description{
Returns a JSON document that captures the 'schema' of the collection of
document(s) passed in, as a JSON string. The schema collapses complex
JSON into a simple form using the following rules:
}
\details{
string  -> "string",       e.g., "a sentence" -> "string"
  number  -> "number",       e.g., 32000.1 -> "number"
  true    -> "logical",      e.g., true -> "logical"
  false   -> "logical",      e.g., false -> "logical"
  null    -> "null",         e.g., null -> "null"
  array   -> [<type>]        e.g., [1, 2] -> ["number"]
  object  -> {"key": <type>} e.g., {"age": 32} -> {"age": "number"}

For more complex JSON objects, ties are broken by taking the most
complex example (using \code{json_complexity}), and then by type
(using \code{json_types}).

This means that if a key has varying schema across documents, the
most complex schema will be chosen as being representative. Similarly,
if the elements of an array vary in schema, the most complex element is
chosen, and if arrays vary in schema across documents, the most
complex is chosen.
}
\examples{

# A simple string
'"string"' \%>\% json_schema

# A simple object
'{"key": "value"}' \%>\% json_schema

# A complex array is represented by the most complex example
'[{"a": 1}, [1, 2], "a", 1, true, null]' \%>\% json_schema

# Companies example
companies[1] \%>\% json_schema \%>\% plot_json_graph

# Github issues
issues_array <- issues \%>\% gather_array # issues are one large array
issues_schema <- issues_array[1:5, ] \%>\% json_schema # analyze first 5
issues_schema \%>\% plot_json_graph
}

