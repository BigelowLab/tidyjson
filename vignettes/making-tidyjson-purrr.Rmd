---
title: "Making tidyjson purrr"
author: "Jeremy Stanley"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

```{r, echo = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>", fig.width = 7, fig.height = 5)
options(dplyr.print_min = 4L, dplyr.print_max = 4L)
```

## Load required libraries

```{r, message = FALSE}
library(needs)
needs(tidyjson, jsonlite, dplyr, purrr, magrittr, forcats, tibble, tidyr)
```

## Companies Data

Let's work with a sample of the companies data

```{r}
set.seed(1)
samp_co <- companies[sample(1:length(companies), 50)]
```

## `tbl_json`

We are working with a character array of JSON, which tidyjson coerces directly
into a tibble.

```{r}
samp_co %>% as.tbl_json %>% head
```

The JSON is stored as an attribute

```{r}
samp_co %>% as.tbl_json %>% attr("JSON") %>% length
```

We can't put this data directly into fromJSON because it expects a single string
or file

```{r, error = TRUE}
samp_co %>% fromJSON
```  

Rather, we'll have to construct a tibble manually. We can convert each JSON
document to a list using `jsonlite::fromJSON` and iterate over every document
using `purrr::map`.

```{r}
samp_co %>%
  map(fromJSON) %>%
  tibble(json = .)
```

## `gather_keys`

First let's look at the prevalance of keys in the top level

```{r}
samp_co %>%
  gather_keys %>%
  count(key)
```

```{r}
samp_co %>%
  map(fromJSON) %>%
  tibble(json = .) %>%
  mutate(key = json %>% map(names)) %>%
  unnest(key) %>%
  count(key)
```

We can accomplish the same thing using only `purrr` functions, but in general
`dplyr` will be easier:

```{r}
samp_co %>%
  map(fromJSON) %>%
  map(names) %>%
  flatten_chr %>%
  table %>%
  head
```

## `json_types`

Similarly, we can look at the types of the keys

```{r}
samp_co %>%
  gather_keys %>%
  json_types %>%
  count(type)
```

With purrr

```{r}
samp_co %>%
  map(fromJSON) %>%
  tibble(json = .) %>%
  transmute(type = json %>% map(map_chr, class)) %>%
  unnest(type) %>%
  count(type)
```

In some cases we are getting lists and in other cases data.frames. Perhaps if
we turn simplification off in fromJSON:

```{r}
samp_co %>%
  map(fromJSON, simplifyVector = FALSE) %>%
  tibble(json = .) %>%
  transmute(type = json %>% map(map_chr, class)) %>%
  unnest(type) %>%
  count(type)
```

This is better, but it seems to be collapsing the arrays and objects together.

```{r}
samp_co %>%
  map(fromJSON, simplifyVector = FALSE) %>%
  tibble(json = .) %>%
  transmute(type = json %>% map(tidyjson:::determine_types)) %>%
  unnest(type) %>%
  count(type)
```

We get the correct answer by using the internal `tidyjson:::determine_types`
function.

Let's create a new object, `samp_co_tibble` to avoid having to repeat the
`%>% map %>% tibble` sequence.

```{r}
samp_co_tibble <- samp_co %>%
  map(fromJSON, simplifyVector = FALSE) %>%
  tibble(json = .)
```

## `json_lengths`

In tidyjson

```{r}
samp_co %>%
  gather_keys %>%
  json_types %>%
  filter(type %in% c("object", "array")) %>%
  json_lengths %>%
  group_by(key, type) %>%
  summarize(mean.length = mean(length)) %>%
  arrange(desc(mean.length))
```

in purrr

```{r}
samp_co_tibble %>%
  mutate(key    = json %>% map(names),
         type   = json %>% map(tidyjson:::determine_types),
         length = json %>% map(map_int, length)) %>%
  unnest(key, type, length) %>%
  filter(type %in% c("object", "array")) %>%
  group_by(key, type) %>%
  summarize(mean.length = mean(length)) %>%
  arrange(desc(mean.length))
```

## `spread_values`

In order to decide what to capture, let's first look at the columns available
to us

```{r, fig.width = 6, fig.height = 6}
samp_co %>% 
  json_structure %>%
  filter(level == 1 & type != "null") %>%
  count(key, type) %>%
  group_by(type) %>%
  summarize(keys = paste(key, collapse = ", ")) %>%
  spread(type, keys) %>%
  as.list
```

Many of the top level keys are objects or arrays, but some are strings and
numbers, so let's grab a few (noting that `$oid` is nested under `"_id"`.

```{r}
samp_co %>%
  spread_values(
    id            = jstring("_id", "$oid"),
    name          = jstring("name"),
    email_address = jstring("email_address"),
    founded_year  = jnumber("founded_year")
  ) %>% head
```

We can attempt something similar with map_chr for the character strings

```{r, error = TRUE}
samp_co_tibble %>%
  mutate(
    id            = json %>% map_chr("_id", "$oid"),
    name          = json %>% map_chr("name"),
    email_address = json %>% map_chr("email_address"),
    founded_year  = json %>% map_dbl("founded_year")
  )
```

This fails because `email_address`, `number_of_employees` and `founded_year` all
have `null` values in them. We can fix this by handling the NULLs explicitly
using the `null_default` operator in purrr, `%||%`.

```{r}
samp_co_tibble %>%
  mutate(
    id            = json %>% map("_id") %>% map("$oid") %>% map_chr(`%||%`, NA),
    name          = json %>% map("name") %>% map_chr(`%||%`, NA),
    email_address = json %>% map("email_address") %>% map_chr(`%||%`, NA),
    founded_year  = json %>% map("founded_year") %>% map_dbl(`%||%`, NA)
  )
```

Alternatively, we can try to use select to just get the columns we want and then 
unnest them. However, this fails for the same `null` reason as above.

```{r, error = TRUE}
samp_co_tibble %>%
  mutate(sub = json %>% 
    map(. %$% tibble(name, email_address, number_of_employees, founded_year))) %>%
  unnest(sub)
```

If we first map `%||%` at depth `2` to replace `NULL`s with `NA`s then this works:

```{r}
samp_co_tibble %>%
  mutate(sub = json %>%
    at_depth(2, `%||%`, NA) %>%
    map(. %$% tibble(name, email_address, number_of_employees, founded_year))) %>%
  unnest(sub)
```

However, we cannot access `"_id", "$oid"` in this way, in part because it is
nested twice, and in part because `"_id"` begins with an `_`.

## `enter_object`

In tidyjson, we use `enter_object` in order to navigate deeper into objects
that are nested.

```{r}
samp_co %>%
  enter_object("acquisition") %>%
  gather_keys %>%
  json_types %>%
  count(key, type) %>%
  spread(type, n) %>%
  as.data.frame
```

We can go even deeper and look at the `acquiring_company` object:

```{r}
samp_co %>%
  enter_object("acquisition", "acquiring_company") %>%
  gather_keys %>%
  json_types %>%
  count(key, type) %>%
  spread(type, n) %>%
  as.data.frame
```

We can then structure this data as follows:

```{r}
samp_co %>%
  spread_values(name = jstring("name")) %>%
  enter_object("acquisition") %>%
  spread_values(
    year        = jnumber("acquired_year"),
    amount      = jnumber("price_amount"),
    currency    = jstring("price_currency_code"),
    acquired_by = jstring("acquiring_company", "name")
  )
```

Note that `enter_object` drops rows without data.

Now, let's try with purrr

```{r}
samp_co_tibble %>%
  mutate(
    name        = json %>% map("name") %>% map_chr(`%||%`, NA),
    acquisition = json %>% map("acquisition")
  ) %>%
  filter(acquisition %>% map_lgl(is.null) %>% not) %>%
  mutate(
    year        = acquisition %>% map("acquired_year") %>% map_int(`%||%`, NA),
    amount      = acquisition %>% map("price_amount") %>% map_dbl(`%||%`, NA),
    currency    = acquisition %>% map("price_currency_code") %>% map_chr(`%||%`, NA),
    acquired_by = acquisition %>% map("acquiring_company") %>% map("name") %>% map_chr(`%||%`, NA)
  ) %>%
  select(-json, -acquisition)
```

## `gather_array`

Let's look inside of the funding rounds array

```{r}
samp_co %>%
  spread_values(name = jstring("name")) %>%
  enter_object("funding_rounds") %>%
  gather_array %>%
  gather_keys %>%
  json_types %>%
  count(key, type) %>%
  spread(type, n) %>%
  as.data.frame
```

Now we can structure this data as well

```{r}
samp_co %>%
  spread_values(name = jstring("name")) %>%
  enter_object("funding_rounds") %>%
  gather_array("round_number") %>%
  spread_values(
    year   = jnumber("funded_year"),
    round  = jstring("round_code"),
    raised = jnumber("raised_amount")
  ) %>% tbl_df
```

Now with purrr (must be a better way)

```{r}
samp_co_tibble %>%
  mutate(
    name  = json %>% map("name") %>% map_chr(`%||%`, NA),
    rounds = json %>% map("funding_rounds")
  ) %>%
  filter(map_int(rounds, length) > 0) %>%
  mutate(rounds = rounds %>% 
           map(. %>% as.list %>% tibble(rounds = .))
  ) %>%
  unnest(rounds) %>%
  group_by(name) %>%
  mutate(round_number = 1:n()) %>%
  mutate(
    year   = rounds %>% map("funded_year") %>% map_int(`%||%`, NA),
    round  = rounds %>% map("round_code") %>% map_chr(`%||%`, NA),
    raised = rounds %>% map("raised_amount") %>% map_dbl(`%||%`, NA)
  ) %>%
  select(-rounds)
```

```{r}
samp_co_tibble %>%
  mutate(
    name  = json %>% map("name") %>% map_chr(`%||%`, NA),
    rounds = json %>% map("funding_rounds")
  ) %>%
  filter(map_int(rounds, length) > 0) %>%
  mutate(round.df = rounds %>%
    at_depth(3, `%||%`, NA) %>%
    at_depth(2, . %$% tibble(funded_year, round_code, raised_amount)) %>%
    at_depth(1, bind_rows)
  ) %>%
  select(-json, -rounds) %>%
  unnest(round.df) %>%
  group_by(name) %>%
  mutate(round_number = 1:n())
```

## `append_values_*`

In tidyjson, there are `append_values_logical`, `append_values_number` and
`append_values_string` functions which build up additional columns of data.

```{r}
samp_co %>%
  gather_keys %>%
  json_types %>%
  filter(type == "string") %>%
  select(-type) %>%
  append_values_string("value") %>%
  tbl_df %>%
  spread(key, value)
```

In purrr

```{r}
samp_co_tibble %>%
  mutate(document.id = 1:n(),
         key    = json %>% map(names),
         type   = json %>% map(tidyjson:::determine_types),
         value  = json %>% map(~tibble(value = .))) %>%
  unnest(key, type, value) %>%
  filter(type == "string") %>%
  select(-type) %>%
  mutate(value = value %>% map_chr(identity)) %>%
  spread(key, value)
```
